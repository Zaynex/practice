ECMAScript 变量包含两种不同数据类型的值：基本类型值和引用类型值。
第三章讨论了基本5种数据类型 Undefined、Null、Boolean、Number、String。这5种基本数据类型是按值访问的。 引用类型值是指可能由多个值构成的对象。
在将一个值赋值时，解析器必须确定这个值是基本类型还是引用类型值。

引用类型的值是保存在内存中的对象。与其他语言不通，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。
当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。
在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的，但ECMAScript抛弃了这一传统。


### 动态的属性

对于引用类型的值，我们可动态的添加属性和方法：
var person = new Object();
person.name = "Zaynex";
alert(person.name);

对于基本类型值，则不可以

var name = "Zaynex";
name.age = "29";
alert(name.age);  //undefined

在给基本类型赋值时，两个变量不会相互影响；
var num1 = 5;
var num2 = num1;
num1 和 num2的值相互独立，num2的值只是num1中5的一个副本。

当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到新变量分配的空间中。不同的是，这个值的副本实际是一个指针，而这个指针指存储在堆中的一个 对象。

### 复制变量值
```
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "Zaynex";
alert(obj2.name);
```
复制引用类型的值时，同时也会将存储在变量对象中的值也复制一份放到新变量分配的空间中。
不过这个值的副本实际上是一个指针，指向存储在堆中的一个对象。复制操作结束后，两个变量实际上引用同一个对象。


### 函数传参
```
var count = {a:1,b:1};
var addOne = function(obj) {
  obj.a += 1;
  obj.b += 1;
  return obj;
 }
 var ret = addOne(count);
 console.log(ret); // a:2,b:2
 console.log(count); // a:2,b:2
```
因为ret和count共享的是同一个堆内存，所以他们是按共享传递的。（注意，不是按引用传递）


为什么不是按引用传递?
```
 var count = {a:1,b:1};
 var addOne = function(obj) {
  obj = {a:2, b:2};
  return obj;
 }
 var ret = addOne(count);
 console.log(ret); // a:2,b:2
 console.log(count); // a:1,b:1
 ```
 如果count是按引用传递的，那么count会自动被修改为obj的新对象。

 这说明在函数内部修改了参数的值，但原始的引用任然保持不变。
 实际上，在重写obj的时候，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即销毁。

 ** 我们可以把ECMAScript函数的参数想象成局部变量。**


### 检测类型
这一章节在原先的笔记中有详细的记录。
基本类型值在内存中占据固定大小的空间，因此保存在栈内存中。
引用类型值是对象，保存在堆内存中。

## 执行环境及作用域

执行环境（execution context)
- 定义了变量或函数有权访问的其他数据，决定了他们各自的行为。
- 每个执行环境都有一个与之关联的变量对象(variable object),环境中定义的所有变量和函数都保存在这个对象中，解析器在处理数据时会在后台使用它。

** 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入到一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 **
（这段话太重要了！）


#### 作用域链
当代码在一个环境执行时，会创建变量对象的一个作用域链(scope chain)。
用途：保证对执行环境有权访问的所有变量和函数的有序访问（是有序访问，说明是有顺序的）

作用域链的前端，始终都是当前执行的代码所在环境的变量对象。
如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象一开始只包含一个变量，arguments对象（在全局环境中不存在）。

作用域链中的下一个变量对象来自包含（外部）环境，再下一个变量对象来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

#### 标识符解析
沿着作用域链以及一级地搜索标识符的过程。搜索过程从作用域链的前端开始，然后逐级向后回溯。
```
var person = {name:"刘德华", age:50};
(function(){
	var person = {name:"刘德华", age:30};
	(function(){
		//var person = {name:"刘德华", age:10};
		console.log(person.name + person.age + "岁");
	})()
})();
//刘德华30岁
```
以上是一个匿名函数里还有匿名函数，它的好处就是可以立即执行，并且匿名函数中的作用域在函数执行完之后就销毁，不会影响到外部作用域。所以你不至于给每个函数都要取a-z各种变量名生怕重复定义了。
根据标识符解析，先看看内部环境是否有person，如果没有，再进行到外部，外部有一个30岁的刘德华，如果外部没有，那么就访问到全局变量刘德华。

有意思的是，内部环境可以通过作用域链访问外部环境，但是外部环境不能通过作用域链访问内部环境。
```
var person = {name:"刘德华", age:50};
(function(){
  var person = {name:"刘德华", age:30};
  console.log(person2.name + person2.age + "岁");
  //Uncaught ReferenceError: person2 is not defined
  (function(){
    var person2 = {name:"Zaynex",age:22};
    //var person = {name:"刘德华", age:10};
    console.log(person.name + person.age + "岁");
  })()
})();
//刘德华30岁
```
我们在第一个匿名函数中调用person2，但是person2是定义在第二个匿名函数内的。根据上述原则，外部匿名函数无法访问内部匿名函数，因此person2找不到，系统自然就报错啦。

### 延长作用域链
1. try-catch语句中的 catch语句块
2. with语句

对于with来说，会将制定的对象添加到作用域链中。
对于catch来说，会创建一个新的变量对象，其中包含的是被抛出错误对象的声明。
```
function buildUrl() {
	var qs = "?debug=true";

	with(location) {
		var url = href + qs;
	}
	return url;
}
```
with接受的是location对象，因此其变量对象就包含了location的所有属性和方法。代码就类似于：
```
var url = location.href + location.qs
```
但在严格模式下不允许有with语句，否则视为语法错误。
因为with会降低性能，with中的代码块内部，每个变量被认为是局部变量，如果在局部环境中找不到该变量的定义，就会查找location对象中是否含有同名属性。也会给调试代码增加困难。

### 没有块级作用域
块级作用域就是{...}花括号里面的作用域。
一般而言，我们会以为
```
if(true){
	var color = "blue";
}
alert(color); 
```
在类C语言中，if内的{}执行完毕后会被立即销毁，但JavaScript中，if语句变量声明会将变量添加到当前的执行环境（在这里是全局环境）。
```
for(var i=0;i<10;i++){
	doSomething(i);
}
alert(i); // 10;
```
对于有块级作用域的语言来说，for语句总初始化变量的表达式所定义的变量，只会存在循环中，但是对于JS，即使 i循环结束后，依然存在循环外部的执行环境。

#### 声明变量
使用var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的就是函数环境。
```
function add(num1, num2){
	var sum = num1 + num2;
	return sum;
}
var result = add(1,2); // 3
alert(sum); // 由于sum不是有效变量，因此会导致错误
```
如果你想要访问sum，那么你就需要在函数外部定义 sum,或者在函数内部不用var，把sum当作全局变量。但并不推荐设置为全局变量。
建议在初始化变量之前，一定要先声明。此外，在严格模式下，初始化未经声明的变量会导致错误。

#### 查询标识符
访问局部变量要比访问全局变量快，因为不用向上搜索作用域链。

## 垃圾收集
函数中的局部变量都有正常的生命周期。局部变量只在函数执行时存在。而这个过程，会为局部变量在栈（或堆）上分配相应的空间，以便存储他们的值。在函数执行完毕，释放它们的内存，功德圆满。

### 标记清除
垃圾收集器在运行时给存储在内存中的所有变量加上标记。然后去掉环境中的变量以及被环境中的变量引用的变量的标记。而在之后再被加上标记的变量被认为准备删除的变量。

### 引用计数
跟踪记录每个值被引用的次数。声明一个变量并将一个引用类型复制给变量时，这个值的引用次数为1。如果同一个值又被赋值给另一个变量，则该值引用次数+1。相反，
如果包含对这个值的引用的变量又取得了另外一个值，则这个值的引用次数-1。当引用次数为0时，没办法再访问这个值，于是清除引用次数为0的值所占用的内存。
#### 引用计数的坑

循环引用——是指对象A包含一个指向对象B的指针，对象B中也包含一个指向对象A的引用。
```
function problem(){
	var objectA = new Object();
	var objectB = new Object();
	objectA.someOtherObject = objectB;
	objectB.someOtherObject = objectA;
}
```
他们之间相互引用，引用次数都是2，永远不会被清除内存。

为了避免循环引用问题，我们要手工断开他们之间的链接,解除引用。
objectA.someOtherObject = null;
objectB.someOtherObject = null;

解除一个值的引用并不意味着自动回收该值占用的内存，而是让值脱离执行环境，以便垃圾收集器下次运行时回收内存。