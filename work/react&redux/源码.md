setState 机制。
setState使用的是一个队列机制来实现state更新，当执行setState时会将需要更新的state合并后放入状态队列，而不会立即更新 this.state。如果不通过this.setState修改而是直接 this.state 修改值的话，就不会把state放到队列中，下次调用时不会将状态队列进行合并，而忽略之前直接修改的this.state。

有时候因为个人操作出现浏览器卡死的状态，终于找到了原因。

如果在 shouldComponentUpdate 和 componentWillUpdate 中调用 setState。此时的 
this._prendingStateQueue != null 。那么 performUpdateIfNecessary 会调用updateComponent 方法进行组件更新，但 udateComponent又会调用 shouldComponentUpdate 和 componentWillUpdate 造成循环引用，浏览器内存占满后奔溃。
```
var SetIntervalMixin = {
    componentWillMount: function() {
        this.intervals = [];
    },
    setInterval: function() {
        this.intervals.push(setInterval.apply(null, arguments));
    },
    componentWillUnmount: function() {
        this.intervals.map(clearInterval);
    }
};

var App = React.createClass({
    mixins: [SetIntervalMixin], // Use the mixin
    getInitialState: function() {
        return {seconds: 0};
    },
    componentDidMount: function() {
        this.setInterval(this.tick, 1000); // Call a method on the mixin
    },
    tick: function() {
        this.setState({seconds: this.state.seconds + 1});
    },
    render: function() {
        return (
            <p>
                React has been running for {this.state.seconds} seconds.
            </p>
        );
    }
});
```

但如果 MIXIN 里的方法和组件中的方法相同时，会报错。而不会取最后的那个方法。

因为破坏了原有组件的封装，导致其后期难以维护，所以MIXIN被放弃了。采用高阶组件来代替。

高阶函数：就是这个函数是以函数作为参数，或者是输出一个函数。比如 map,reduce,sort
