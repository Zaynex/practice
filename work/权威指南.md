x + "" //转换为String
+x //转换为Number
!!x //转换为Boolean

var data = [8, 9];
"0" in data; // true:数组包含第0的元素
3 in data; //false:数组不包含第三个元素


var hasStrictMode = (function(){
    'use strict';
    return this === undefined
})

delete 只是断开属性和宿主对象间的联系，不会去操作属性中的属性。
所以不会删除继承属性。
比如
a = {
    p: {
        x:1
    }
}

b = a.p;
delete a.p;
b.x;//1,依然可以访问

检测属性的两种方式

1. for in  遍历可枚举的属性，包括继承的属性
2. hasOwnProperty 只检测对象的自身属性
3. propertyIsEnumberable 只遍历可枚举的自有属性

1和2组合就是效果3

Object.keys();//返回对象中所有可枚举的自有属性的名称组成的数组
Object.getOwnpropertyNames();//返回对象所有自有属性名称组成的数组，包含不可枚举的属性
Object.getOwnPropertyDescriptor({x: 1}, x);// 获取对象属性描述符
Object.defineProperty(object, property, {value: 1,writable: true})
Object.isPropertyOf();
var p = {x: 1};
var o = Object.create(p);
p.isPropertyOf(o);// 判断是否为该对象的原型

function classOf() {
    if(o === null) return "Null";
    if(o === undefined ) return 'Undefined';
    return Object.protpType.toString().call(o).slice(8, -1);
}

跳过不存在的元素但仍要处理为undefined元素
for(let i = 0, i < a.length; i++) {
    if(!(i in a)) continue;
}

Array.join();//数组中的元素转换为字符串
有意思的做法：

var b = new Array(100);
b.join("-"); // '-----*100';会生成100个连字符

String.split();// 将字符串转换成数组


var a = [33, 4, 11, 1122];
a.sort(); // [11, 1122, 33, 4]
a.sort((x, y)=> x- y); // [4, 11, 33, 1122]

Array.slice(start, end);// 获取指定的片段，数组起始位置和结束位置,如果遇到负数则加上数组长度 

Array.splice(start, index, [...]);

数组方法：遍历、映射、过滤、检测、简化、搜索。
var data = [...];
data.forEach(function(value, index, array), this);

forEach遍历数组，为每个元素调用指定的函数。
forEach不会在所有元素都传递给调用的函数之前终止遍历。比如把forEach()放到一个try中并且抛出异常才能提前终止。  

function foreach(a, f, t) {
    try{(a.forEach(f,t))}
    catch(e) {
        if(e === foreach.break) return;
        else throw e;
    }
}
foreach.break = new Error("stop");

map将调用的数组的每个元素传递给指定的函数，并返回一个数组。
filter返回逻辑判断为true的数组。
a = a.filter(x => x !== undefined && x != null)

reduce()使用指定的函数讲数组元素进行组合，生成单个值。


function findall(a, x) {
    var results = [],
        len = a.length,
        pos = 0;
    while(pos < len) {
        pos = a.indexOf(x, pos);
        if(pos === -1) break;
        results.push(pos);
        pos = pos + 1    
    }
    return results;
}

var isArray = Function.isArray || function(o) {
    return typeof o === 'object' && 
    Object.prototype.toString.call(o) === '[object Array]'
}

撸一个 map()

var map = Array.prototype.map ? function(a, f) return a.map(f) :
    function(a, f) {
    var results = [];
    for(let i = 0, len = a.length; i < len; i++) {
        if(i in a) results[i] = f.call(null, a[i], i, a)
}
}

