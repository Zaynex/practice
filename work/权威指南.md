x + "" //转换为String
+x //转换为Number
!!x //转换为Boolean

var data = [8, 9];
"0" in data; // true:数组包含第0的元素
3 in data; //false:数组不包含第三个元素


var hasStrictMode = (function(){
    'use strict';
    return this === undefined
})

delete 只是断开属性和宿主对象间的联系，不会去操作属性中的属性。
所以不会删除继承属性。
比如
a = {
    p: {
        x:1
    }
}

b = a.p;
delete a.p;
b.x;//1,依然可以访问

检测属性的两种方式

1. for in  遍历可枚举的属性，包括继承的属性
2. hasOwnProperty 只检测对象的自身属性
3. propertyIsEnumberable 只遍历可枚举的自有属性

1和2组合就是效果3

Object.keys();//返回对象中所有可枚举的自有属性的名称组成的数组
Object.getOwnpropertyNames();//返回对象所有自有属性名称组成的数组，包含不可枚举的属性
Object.getOwnPropertyDescriptor({x: 1}, x);// 获取对象属性描述符
Object.defineProperty(object, property, {value: 1,writable: true})
Object.isPropertyOf();
var p = {x: 1};
var o = Object.create(p);
p.isPropertyOf(o);// 判断是否为该对象的原型

function classOf() {
    if(o === null) return "Null";
    if(o === undefined ) return 'Undefined';
    return Object.protpType.toString().call(o).slice(8, -1);
}

跳过不存在的元素但仍要处理为undefined元素
for(let i = 0, i < a.length; i++) {
    if(!(i in a)) continue;
}

Array.join();//数组中的元素转换为字符串
有意思的做法：

var b = new Array(100);
b.join("-"); // '-----*100';会生成100个连字符

String.split();// 将字符串转换成数组


var a = [33, 4, 11, 1122];
a.sort(); // [11, 1122, 33, 4]
a.sort((x, y)=> x- y); // [4, 11, 33, 1122]

Array.slice(start, end);// 数组起始位置和结束位置,如果遇到负数则加上数组长度 